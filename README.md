# Java-Lab3

# Отчет по работе: Реализация задач на Java
Бочкарёв Егор ИТ-13,14

## Общее описание
Данный проект представляет собой консольное приложение на Java, которое реализует 8 различных задач:

Внутри 4 "пакета" с файлами

1 - Main с вызовом всех задач и пользовательским интерфейсом

2 - Check с проверкой входных данных

3 - City с городами и дорогами

4 - Fraction для действий с дробями

Программа предлагает пользователю выбрать задачу через меню, затем выполняет соответствующую функцию.

## Структура проекта
- Класс `Main` с вызовом всех задач и пользовательским интерфейсом
- Класс `Check` для проверки входных данных
- Класс `Fraction` и его интерфейс `Summable`, который работает с дробями
- Класс `City` и `Way`, которые нужны для выполнения разных задач с городами на карте

## Детальный анализ методов

### Задание 1.4 (Дроби)

**<ins>Задача:</ins>**

Измените сущность Дробь из задачи 1.5.5. Реализуйте следующие требования:
+ Дробь не может быть изменена после создания
+ Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным.

Продемонстрируйте работоспособность решения на примерах.

**<ins>Метод решения:</ins>**

Эта задача решается дополнением класса `Fraction` с прошлой лабораторной работы.

Внутри класса 2 поля: `numerator` и `denominator`. Они имеют параметр `final`, что не дает им изменяться после инициализации. Также есть конструктор, в котором проверяется поле `denominator` на равеноство 0. Если оно выполняется, то система заканчивает работу. Для каждого поля также есть геттер и сеттер.

В классе также содержится 4 метода арифметических операций с дробями: сложение, вычитание, умножение, деление. И 4 метода арифметических операций с целыми числами: сложение, вычитание, умножение, деление. В делении также есть проверка на деление на 0. Эти операции реализованы как обычные действия с дробями (В сложении и вычитании 2 дроби приводятся к общему знаменателю, а при делении числитель и знаменатель второй дроби меняются местами и производится умножение).

В классе есть метод `toString`, который выводит ответ строкой в формате `numerator / denominator`.

В `Main` создаётся с клавиатуры две дроби. После чего проводятся операции: с дробями, с целым числом и дробью, кэширование вещественного значения дробей, проверка равенства дробей, изменение дроби.

**<ins>Код реализации:</ins>**

```
private final int numerator;  // числитель
private final int denominator; // знаменатель
```

**<ins>Вывод на экран:</ins>**

Введите числитель: 2

Введите знаменатель: 3

Создана дробь: 2/3

Введите числитель второй дроби: 5

Введите знаменатель второй дроби: 9

Создана дробь: 5/9

Сложение дробей: 33/27

Вычитание дробей: 3/27

Умножение дробей: 10/27

Деление дробей: 18/15

Введите целое число для операции: 2

Сложение с числом: 8/3

Вычитание с числом: -4/3

Умножение на число: 4/3

Деление на число: 2/6
***

### Задание 1.10 (Дороги)

**<ins>Задача:</ins>**

Измените сущности из задачи 1.3.3. Гарантируйте, что между двумя городами может быть только одна прямая дорога (другой путь может быть проложен только транзитом через другие города). Города можно создавать с указанием заранее заданных путей, в любой момент времени можно добавить новую дорогу в любой город и удалить имеющуюся дорогу.

**<ins>Метод решения:</ins>**

Эта задача решается дополнением класса `City` из предыдущей лабораторной работы.

Внутри класса 2 поля: `name`, который хранит название города и `ways`, словарь дорог к другим городам с длинной. Класс имеет 2 конструктора: с названием города и пустым списком дорог от него и название города со списком дорог и их длинами. Также класс содержит по геттеру для каждого поля и сеттер для названия.

Также есть метод добавления дорог от города к городу. В методе есть проверка на пустое название города, неположительную длину дороги и дороги в себя же. Также дорога не должна быть создана ранее (она просто не создается, если уже есть).

Следующий метод `removeRoad` удаляет дорогу между городами, но прежде делает проверку на пустое название введенного города и наличие удаляемой дороги. Удаление происходит с 2-х сторон, то есть дорога удаляется из списка 1 и 2 города.

Также есть стандартный для всех классов метод `toString`, который выводит результат в строковом представлении.

В `Main` реализуем сценарий работы.

**<ins>Код реализации:</ins>**

```
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

public class City {
    private String name;
    private Map<City, Integer> ways;

    public City(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Название города не может быть пустым");
        }
        this.name = name;
        this.ways = new HashMap<>();
    }

    public City(String name, Map<City, Integer> roads) {
        this(name);
        if (roads != null) {
            for (Map.Entry<City, Integer> entry : roads.entrySet()) {
                addWays(entry.getKey(), entry.getValue());
            }
        }
    }

    public String getName() {
        return name;
    }

    public Map<City, Integer> getWays() {
        return new HashMap<>(ways);
    }

    public void addWays(City city, int distance) {
        validateCity(city);
        if (distance <= 0) {
            throw new IllegalArgumentException("Расстояние должно быть положительным");
        }

        if (ways.containsKey(city)) {
            throw new IllegalArgumentException("Дорога между " + name + " и " + city.name + " уже существует");
        }

        this.ways.put(city, distance);
        city.ways.put(this, distance);
    }

    public void removeWay(City city) {
        validateCity(city);

        if (!ways.containsKey(city)) {
            throw new IllegalArgumentException("Дорога между " + name + " и " + city.name + " не существует");
        }

        this.ways.remove(city);
        city.ways.remove(this);
    }

    public boolean hasWayTo(City city) {
        return ways.containsKey(city);
    }

    public Integer getDistanceTo(City city) {
        return ways.get(city);
    }

    private void validateCity(City city) {
        if (city == null) {
            throw new IllegalArgumentException("Город не может быть null");
        }
        if (city == this) {
            throw new IllegalArgumentException("Нельзя создать дорогу из города в себя");
        }
    }

    public static void printRoads(City... cities) {
        for (City city : cities) {
            System.out.print("   " + city.getName() + " → ");
            Map<City, Integer> roads = city.getWays();
            if (roads.isEmpty()) {
                System.out.println("Нет дорог");
            } else {
                boolean first = true;
                for (Map.Entry<City, Integer> road : roads.entrySet()) {
                    if (!first) System.out.print(", ");
                    System.out.print(road.getKey().getName() + " Расстояние:" + road.getValue());
                    first = false;
                }
                System.out.println();
            }
        }
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder(name);
        if (!ways.isEmpty()) {
            sb.append(" -> ");
            boolean first = true;
            for (Map.Entry<City, Integer> entry : ways.entrySet()) {
                if (!first) sb.append(", ");
                sb.append(entry.getKey().name).append(":").append(entry.getValue());
                first = false;
            }
        }
        return sb.toString();
    }
}
```

**<ins>Вывод на экран:</ins>**

Сколько городов создать? 6

Введите название города 1: Ошибка: название города не может быть пустым

Введите название города 1: A

Введите название города 2: B

Введите название города 3: C

Введите название города 4: D

Введите название города 5: E

Введите название города 6: F

Сколько дорог добавить? 8

Дорога 1:

Введите номер первого города (1-6): 1

Введите номер второго города (1-6): 2

Введите расстояние: 5

Дорога добавлена успешно!

Дорога 2:

Введите номер первого города (1-6): 2

Введите номер второго города (1-6): 3

Введите расстояние: 3

Дорога добавлена успешно!

Дорога 3:

Введите номер первого города (1-6): 3

Введите номер второго города (1-6): 4

Введите расстояние: 4

Дорога добавлена успешно!

Дорога 4:

Введите номер первого города (1-6): 4

Введите номер второго города (1-6): 5

Введите расстояние: 2

Дорога добавлена успешно!

Дорога 5:

Введите номер первого города (1-6): 5

Введите номер второго города (1-6): 6

Введите расстояние: 2

Дорога добавлена успешно!

Дорога 6:

Введите номер первого города (1-6): 4

Введите номер второго города (1-6): 1

Введите расстояние: 6

Дорога добавлена успешно!

Дорога 7:

Введите номер первого города (1-6): 1

Введите номер второго города (1-6): 6

Введите расстояние: 1

Дорога добавлена успешно!

Дорога 8:

Введите номер первого города (1-6): 6

Введите номер второго города (1-6): 2

Введите расстояние: 1

Дорога добавлена успешно!

Результат:

   A → B Расстояние:5, F Расстояние:1, D Расстояние:6
   
   B → A Расстояние:5, F Расстояние:1, C Расстояние:3
   
   C → B Расстояние:3, D Расстояние:4
   
   D → A Расстояние:6, E Расстояние:2, C Расстояние:4
   
   E → F Расстояние:2, D Расстояние:2
   
   F → A Расстояние:1, E Расстояние:2, B Расстояние:1
***

### Задание 3.1 (Запретная Дробь)

**<ins>Задача:</ins>**

Измените сущность Дробь, полученную в задаче 2.1.4. Гарантируйте, что невозможно создать такой подвид дроби, который позволял бы создавать Дроби с изменяемым состоянием.

**<ins>Метод решения:</ins>**

Для решения модернизируется класс `Fraction` из 1 задачи 1 задания. В поля `numerator` и `denominator` добавяется параметр final, который не дает изменять переменную после её инициализации. Также сам класс получает параметр `final`, что означает, что класс нельзя наследовать. Также во всех операциях нет изменений данных. Операции возвращают новые объекты.

**<ins>Код реализации:</ins>**

```
public final class Fraction extends Number implements Summable, Cloneable
```

```
private final int numerator;  // числитель
private final int denominator; // знаменатель
```

**<ins>Вывод на экран:</ins>**

Введите числитель: 2

Введите знаменатель: 3

Создана дробь: 2/3

Введите числитель второй дроби: 5

Введите знаменатель второй дроби: 9

Создана дробь: 5/9

Сложение дробей: 33/27

Вычитание дробей: 3/27

Умножение дробей: 10/27

Деление дробей: 18/15

Введите целое число для операции: 2

Сложение с числом: 8/3

Вычитание с числом: -4/3

Умножение на число: 4/3

Деление на число: 2/6
***

### Задание 4.2 (Дробь это число)

**<ins>Задача:</ins>**

Измените сущность Дробь, полученную в задаче 2.3.1. Дробь должна быть подтипом класса Number. Данный класс входит в стандартную редакцию языка Java.

**<ins>Метод решения:</ins>**

Для решения задачи мы также модернизируем класс `Fraction`. Мы создаем наследование из класса `Number` и реализовываем все его абстрактные методы: возвращение целого числа, целого числа больше значения int, дробного числа типа float и double методами `intValue`, `longValue`, `floatValue` и `doubleValue` соответственно.

В `Main` наглядно показывается полиморфизм тем, что создается дробь и переприсваивается переменной типа `Number`. С этой переменной можно работать как с обычной дробью. После реализуются все стандартные методы Number.

**<ins>Код реализации:</ins>**

```
 // Переопределение абстрактных методов Number
    @Override
    public int intValue() {
        return numerator / denominator; // возвращаем целую часть
    }

    @Override
    public long longValue() {
        return (long) numerator / denominator; // возвращаем целую часть как long
    }

    @Override
    public float floatValue() {
        return (float) numerator / denominator; // возвращаем значение как float
    }

    @Override
    public double doubleValue() {
        return (double) numerator / denominator; // возвращаем значение как double
    }
```

**<ins>Вывод на экран:</ins>**

Введите числитель: 3

Введите знаменатель: 4

Создана дробь: 3/4

Введите числитель второй дроби: 1

Введите знаменатель второй дроби: 3

Создана дробь: 1/3

Сложение дробей: 13/12

Вычитание дробей: 5/12

Умножение дробей: 3/12

Деление дробей: 9/4

Введите целое число для операции: 2

Сложение с числом: 11/4

Вычитание с числом: -5/4

Умножение на число: 6/4

Деление на число: 3/8

Реализация методов Number: 

intValue: 0

longValue: 0

floatValue: 0.75

doubleValue: 0.75
***

### Задание 5.1 (Сложение)

**<ins>Задача:</ins>**

Разработайте метод, который принимает набор числовых значенийи возвращает их сумму в вещественной форме. С использованием данного метода выполните следующие сложения:
+ 2 + 3\5 + 2.3
+ 3.6 + 49\12 + 3 + 3\2
+ 1\3 + 1

**<ins>Метод решения:</ins>**

Задача решается модернизацией класса `Fraction`. Мы создаем интерфэйс `Summable` для операции сложения, который возвращает ответ в вещественной форме. Также создается новый файл `Summable` чтобы реализовать интерфейс, который возвращает десятичное значение дроби из класса `Fraction`.

В `Main` создаются заданные дроби, затем реализуется сложения и вывод на экран.

**<ins>Код реализации:</ins>**

```
public interface Summable {
    double toDouble();  // Метод для преобразования объекта в вещественное число
}
```

```
@Override
public double toDouble() {
    return (double) numerator / denominator;
}
```

**<ins>Вывод на экран:</ins>**

Результат 1: 4.9

Результат 2: 12.183333333333334

Результат 3: 1.3333333333333333
***

### Задание 6.5 (Сравнение городов)

**<ins>Задача:</ins>**

Измените сущность Город, полученную в задаче 2.1.10. Переопределите метод сравнения объектов по состоянию таким образом, чтобы два Города считались одинаковыми тогда, когда у них одинаковый набор путей в другие города. Также, подвид Города из задачи 2.3.3 должен быть сравним с городом из задачи 2.1.10.

**<ins>Метод решения:</ins>**

Задача решается модернизацией класса `City`, а точнее дополнением методом `sameWays`. Внутри него есть проверка на пустое название города, затем инициализируется счетчик, который считает совпадения городов. Затем вложенные циклы, где сначала проходим по дорогам текущего города, а во вложенном цикле по дорогам другого города и смотрим совпадения. Если все дороги совпали, то города считаются одинаковыми.

В `Main` создается 4 города, 1 и последнему добавляются одинаковые пути во 2 и 3 с одинаковым расстоянием. Далее демонстрируется, что города "Равны" при одинаковом наборе путей, что и требуется по условию.

**<ins>Код реализации:</ins>**

```
public boolean sameWays(City other) {
        if (other == null || this.ways.size() != other.ways.size()) {
            return false;
        }

        for (Map.Entry<City, Integer> entry : this.ways.entrySet()) {
            City target = entry.getKey();
            Integer distance = entry.getValue();

            boolean found = false;
            for (Map.Entry<City, Integer> otherEntry : other.ways.entrySet()) {
                if (otherEntry.getKey().getName().equals(target.getName()) &&
                        otherEntry.getValue().equals(distance)) {
                    found = true;
                    break;
                }
            }

            if (!found) return false;
        }

        return true;
    }

    public boolean equalsByWays(Object obj) {
        if (obj == null) return false;
        if (obj instanceof City other) {
            return sameWays(other);
        }
        return false;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        City city = (City) obj;
        return Objects.equals(name, city.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
```

**<ins>Вывод на экран:</ins>**

Сколько городов создать для сравнения? 3

Введите название города 1: Ошибка: название города не может быть пустым

Введите название города 1: A

Введите название города 2: B

Введите название города 3: C

Созданные города:

1. A

2. B
   
3. C

Добавление дорог к городу A ---

Сколько дорог добавить? 2

Дорога 1:

К какому городу подключить? (введите номер 2, 3): 2

Введите расстояние: 3

Дорога к B добавлена

Дорога 2:

К какому городу подключить? (введите номер 3): 3

Введите расстояние: 5

Дорога к C добавлена

Добавление дорог к городу B

Сколько дорог добавить? 1

Дорога 1:

К какому городу подключить? (введите номер 3): 3

Введите расстояние: 2


✓ Дорога к C добавлена

Результат

   A → B Расстояние:3, C Расстояние:5
   
   B → A Расстояние:3, C Расстояние:2
   
   C → A Расстояние:5, B Расстояние:2
   
Сравнение

A vs B:

• sameWays (по путям): false

• equalsByWays (универсальное): false

• equals (по имени): false
***

### Задание 7.1 (Навести порядок)

**<ins>Задача:</ins>**

Данная задача предполагает реорганизацию ранее написанных классов. Расположите все ранее написанные классы по пакетам таким образом, чтобы логически близкие классы оказались сгруппированы друг с другом. Имена пакетов должны иметь как минимум трехсоставную форму, вида: ru.surname.type. Вместо surname следует подставить свою фамилию, а вместо type подставить название логического блока. Например, классы описывающие точку, линию, ломаную линию, фигуру, квадрат, треугольник, круг и прямоугольник можно расположить в пакете ru.surname.geometry.

**<ins>Метод решения:</ins>**

Первая задача решается созданием "Пакетов", в которые перемещаются файлы с одинаковой тематикой. Например в "Пакет" `City` отправляется 2 файла: `City` и `Way`, вель они взаимосвязаны. Один создает города, а второй дороги между ними. По итогу создается 4 "Пакета":
`Main` - внутри файл `Main` с основным меню пользователя и интерфейсом `Summable` для 5 задания
`Fraction` - внутри файл `Fraction` для всех действий с дробями
`City` - внутри файл `City` для создания городов и прямыми путями между ними и файл `Way` с путями из одного города в другой в том числе транзитом через ещё один и созданием в любой момент времени
`Check` - внутри файл `Check` с проверкой вводимых данных
***

### Задание 7.2 (Главный метод)

**<ins>Задача:</ins>**

Создайте пакет ru.surname.main (вместо surname необходимо подставить собственную фамилию) в котором расположить класс с точкой входа в исполнение программы (public static void main). Также следует проверить, что ни в одном другом пакете нет классов имеющих точку входа в исполнение программы. В этом же пакете необходимо расположить класс (или интерфейс) с методами из задач блока 2.5 и продемонстрировать их работоспособность.
***

### Задание 7.3 (Возведение в степень)

**<ins>Задача:</ins>**

Создайте метод принимающий две строки, в которых будут записаны числа X и Y. Возвращает метод результат возведения X в степень Y. Для преобразования строки в число следует использовать метод Integer.parseInt, а для возведения в степень метод Math.pow. Вызовите разработанный метод передав туда параметры командной строки полученные точкой входа в программу. Реализуйте метод так, что бы для возведения в степень и преобразования строки использовались короткие имена статических методов.

**<ins>Метод решения:</ins>**

Для выполнения последней задачи из 7 задания создается отдельный класс `Power`. В нем обрабатывается 2 строки, переводится в число с помощью `Integer.parseInt` и первое число возводится в степень второго числа с помощью `pow`. Данные передаются точкой входа в программу.

**<ins>Код реализации:</ins>**

```
public static double Power(String x, String y) {
        int x1 = parseInt(x);
        int y1 = parseInt(y);
        return pow(x1, y1);
    }
```

**<ins>Вывод на экран:</ins>**

Результат возведения 3 в степень 5: 243.0
***

### Задание 8.3 (Клонирование дроби)

**<ins>Задача:</ins>**

Измените сущность Дробь из 2.6.1. Переопределите метод клонирования, унаследованный от класса Object, таким образом, чтобы при его вызове возвращался новый объект Дроби, значения полей которого будут копиями оригинальной Дроби.

**<ins>Метод решения:</ins>**

Задача решается модернизацией класса `City`, а точнее дополнением методом `sameWays`. Внутри него есть проверка на пустое название города, затем инициализируется счетчик, который считает совпадения городов. Затем вложенные циклы, где сначала проходим по дорогам текущего города, а во вложенном цикле по дорогам другого города и смотрим совпадения. Если все дороги совпали, то города считаются одинаковыми.

В `Main` создается 4 города, 1 и последнему добавляются одинаковые пути во 2 и 3 с одинаковым расстоянием. Далее демонстрируется, что города "Равны" при одинаковом наборе путей, что и требуется по условию.

**<ins>Код реализации:</ins>**

```
// Переопределение метода clone()
    @Override
    public Fraction clone() {
        try {
            // Можно вызвать super.clone(), но проще — создать новый объект вручную
            return new Fraction(this.numerator, this.denominator);
        } catch (Exception e) {
            throw new AssertionError("Ошибка клонирования: " + e.getMessage());
        }
    }

// Переопределение equals
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Fraction other = (Fraction) obj;
        return numerator * other.denominator == denominator * other.numerator;
    }

// Переопределение hashCode
    @Override
    public int hashCode() {
        return 31 * numerator + denominator;
    }
```

**<ins>Вывод на экран:</ins>**

Оригинал: 3/5
Клон: 3/5
Ссылки равны? false
***

## Вспомогательные методы

+ `public int readInt(Scanner scanner)`

Что делает:

Читает из Scanner целое число, пока пользователь не введёт корректное значение.

Как работает (пошагово):
- Заходит в бесконечный цикл while (true).
- Печатает приглашение "Введите целое число: ".
- Проверяет scanner.hasNextInt() — есть ли следующий токен, который можно распарсить как int.
- Если true: читает int num = scanner.nextInt(); и возвращает num.
- Иначе: печатает сообщение об ошибке и вызывает scanner.next() — чтобы "съесть" неверный токен (иначе hasNextInt() будет снова false и цикл застрянет).

Примеры:

При вводе 42 вернёт 42; при вводе abc — попросит ввести ещё раз.

Код:
```
public int readInt(Scanner scanner) {
        while (true) {
            System.out.print("Введите целое число: ");
            if (scanner.hasNextInt()) {
                int num = scanner.nextInt();
                return num;
            } else {
                System.out.println("Ошибка: введите целое число!");
                scanner.next(); // очищаем неверный ввод
            }
        }
    }
```
